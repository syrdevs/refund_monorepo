{"version":3,"sources":["../../../src/utils/request.js"],"names":["codeMessage","checkStatus","response","status","errortext","statusText","notification","error","message","description","clone","json","then","r","Message","Error","name","request","url","option","options","defaultOptions","credentials","newOptions","method","body","FormData","headers","Accept","JSON","stringify","authToken","Authorization","fetch","text","catch","e","window","g_app","_store","dispatch","type"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;AAGA,IAAMA,WAAW,GAAG;AAClB,OAAK,+CADa;AAElB,OAAK,uCAFa;AAGlB,OAAK,uDAHa;AAIlB,OAAK,0BAJa;AAKlB,OAAK,yGALa;AAMlB,OAAK,8EANa;AAOlB,OAAK,gDAPa;AAQlB,OAAK,4EARa;AASlB,OAAK,6BATa;AAUlB,OAAK,mEAVa;AAWlB,OAAK,kDAXa;AAYlB,OAAK,qDAZa;AAalB,OAAK,gBAba;AAclB,OAAK,oEAda;AAelB,OAAK;AAfa,CAApB;;AAkBA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAC,QAAQ,EAAI;AAE9B,MAAIA,QAAQ,CAACC,MAAT,IAAmB,GAAnB,IAA0BD,QAAQ,CAACC,MAAT,GAAkB,GAAhD,EAAqD;AACnD,WAAOD,QAAP;AACD;;AAGD,MAAME,SAAS,GAAGJ,WAAW,CAACE,QAAQ,CAACC,MAAV,CAAX,IAAgCD,QAAQ,CAACG,UAA3D;AACA,MAAIH,QAAQ,CAACC,MAAT,IAAmB,GAAvB,EACEG,mBAAaC,KAAb,CAAmB;AACjB;AACAC,IAAAA,OAAO,sFAAmBN,QAAQ,CAACC,MAA5B,CAFU;AAGjBM,IAAAA,WAAW,EAAE;AAHI,GAAnB;;AAMF,MAAIP,QAAQ,CAACC,MAAT,KAAoB,GAApB,IAA4BD,QAAQ,CAACC,MAAT,IAAmB,GAAnB,IAA0BD,QAAQ,CAACC,MAAT,GAAkB,GAA5E,EAAkF;AAEhF,QAAID,QAAQ,CAACG,UAAT,KAAwB,WAA5B,EAAyC;AACvCH,MAAAA,QAAQ,CAACQ,KAAT,GAAiBC,IAAjB,GAAwBC,IAAxB,CAA6B,UAACC,CAAD,EAAO;AAClCP,2BAAaC,KAAb,CAAmB;AACjB;AACAC,UAAAA,OAAO,sFAAmBN,QAAQ,CAACC,MAA5B,CAFU;AAGjBM,UAAAA,WAAW,EAAEI,CAAC,CAACC;AAHE,SAAnB;AAKD,OAND;AAOD,KARD,MASK,CACH;AACD;;AACD,WAAOZ,QAAP;AACD;;AAED,MAAMK,KAAK,GAAG,IAAIQ,KAAJ,CAAUX,SAAV,CAAd;AACAG,EAAAA,KAAK,CAACS,IAAN,GAAad,QAAQ,CAACC,MAAtB;AACAI,EAAAA,KAAK,CAACL,QAAN,GAAiBA,QAAjB;AACA,QAAMK,KAAN;AACD,CApCD;AAuCA;;;;;;;;;AAOe,SAASU,OAAT,CAAiBC,GAAjB,EAAsBC,MAAtB,EAA8B;AAC3C,MAAMC,OAAO,qBAERD,MAFQ,CAAb;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAEA,MAAME,cAAc,GAAG;AACrBC,IAAAA,WAAW,EAAE;AADQ,GAAvB;;AAGA,MAAMC,UAAU,qBAAQF,cAAR,EAA2BD,OAA3B,CAAhB;;AACA,MACEG,UAAU,CAACC,MAAX,KAAsB,MAAtB,IACAD,UAAU,CAACC,MAAX,KAAsB,KADtB,IAEAD,UAAU,CAACC,MAAX,KAAsB,QAHxB,EAIE;AACA,QAAI,EAAED,UAAU,CAACE,IAAX,YAA2BC,QAA7B,CAAJ,EAA4C;AAC1CH,MAAAA,UAAU,CAACI,OAAX;AACEC,QAAAA,MAAM,EAAE,kBADV;AAEE,wBAAgB;AAFlB,SAGKL,UAAU,CAACI,OAHhB;AAKAJ,MAAAA,UAAU,CAACE,IAAX,GAAkBI,IAAI,CAACC,SAAL,CAAeP,UAAU,CAACE,IAA1B,CAAlB;AACD,KAPD,MAOO;AACL;AACAF,MAAAA,UAAU,CAACI,OAAX;AACEC,QAAAA,MAAM,EAAE;AADV,SAEKL,UAAU,CAACI,OAFhB;AAID;AACF;;AAED,MAAMI,SAAS,GAAG,sBAAQ,IAAR,CAAlB;;AAEA,MAAIA,SAAJ,EAAe;AACbR,IAAAA,UAAU,CAACI,OAAX;AACEK,MAAAA,aAAa,EAAE,YAAYD;AAD7B,OAEKR,UAAU,CAACI,OAFhB;AAID,GALD,MAKO;AACL,QAAIJ,UAAU,CAACI,OAAX,IAAsBJ,UAAU,CAACI,OAAX,CAAmBK,aAA7C,EACE,OAAOT,UAAU,CAACI,OAAX,CAAmBK,aAA1B;AACH;AAED;;;;;;;;;;;;;;;;;;AAiBA,SAAOC,KAAK,CAACf,GAAD,EAAMK,UAAN,CAAL,CACJX,IADI,CACCX,WADD,EAEL;AAFK,GAGJW,IAHI,CAGC,UAAAV,QAAQ,EAAI;AAChB;AACA;AACA,QAAIqB,UAAU,CAACC,MAAX,KAAsB,QAAtB,IAAkCtB,QAAQ,CAACC,MAAT,KAAoB,GAA1D,EAA+D;AAC7D,aAAOD,QAAQ,CAACgC,IAAT,EAAP;AACD;;AACD,WAAOhC,QAAQ,CAACS,IAAT,EAAP;AACD,GAVI,EAWJwB,KAXI,CAWE,UAAAC,CAAC,EAAI;AAEV,QAAMjC,MAAM,GAAGiC,CAAC,CAACpB,IAAjB;;AACA,QAAIb,MAAM,KAAK,GAAf,EAAoB;AAClB;;AACA;AAEAkC,MAAAA,MAAM,CAACC,KAAP,CAAaC,MAAb,CAAoBC,QAApB,CAA6B;AAC3BC,QAAAA,IAAI,EAAE;AADqB,OAA7B;;AAIA,aAAO;AACLtC,QAAAA,MAAM,EAAEA,MADH;AAELK,QAAAA,OAAO,EAAE4B;AAFJ,OAAP;AAID,KAfS,CAgBV;;;AACA,QAAIjC,MAAM,KAAK,GAAf,EAAoB;AAClB;AACA;AACD;;AACD,QAAIA,MAAM,IAAI,GAAV,IAAiBA,MAAM,IAAI,GAA/B,EAAoC;AAClC;AACA;AACD;;AACD,QAAIA,MAAM,IAAI,GAAV,IAAiBA,MAAM,GAAG,GAA9B,EAAmC,CACjC;AACD;;AAED,WAAO;AACLA,MAAAA,MAAM,EAAEA,MADH;AAELK,MAAAA,OAAO,EAAE4B;AAFJ,KAAP;AAID,GA5CI,CAAP;AA6CD","sourcesContent":["import { notification } from 'antd';\nimport setAuth from './setAuth';\n\n\nconst codeMessage = {\n  200: 'Сервер успешно возвратил запрошенные данные. ',\n  201: 'Новые или измененные данные успешны. ',\n  202: 'Запрос вошел в фоновую очередь (асинхронная задача). ',\n  204: 'Удалите данные успешно. ',\n  400: 'Запрос был отправлен с ошибкой. Сервер не выполнял никаких операций для создания или изменения данных. ',\n  401: 'Пользователь не имеет разрешения (токен, имя пользователя, пароль неверны). ',\n  403: 'Пользователь авторизован, но доступ запрещен. ',\n  404: 'Запрос был сделан для записи, которая не существует, и сервер не работал. ',\n  406: 'Формат запроса недоступен. ',\n  410: 'Запрошенный ресурс удаляется навсегда и больше не будет получен. ',\n  422: 'При создании объекта произошла ошибка проверки. ',\n  500: 'Сервер имеет ошибку, пожалуйста, проверьте сервер. ',\n  502: 'Ошибка шлюза. ',\n  503: 'Услуга недоступна, сервер временно перегружен или поддерживается. ',\n  504: 'Нет дотупа к серверу. ',\n};\n\nconst checkStatus = response => {\n\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  }\n\n\n  const errortext = codeMessage[response.status] || response.statusText;\n  if (response.status >= 500)\n    notification.error({\n      // message: `Ошибка ${response.status}: ${response.url}`,\n      message: `Ошибка статус ${response.status}`,\n      description: 'Сервис временно недоступен',\n    });\n\n  if (response.status === 400 || (response.status >= 402 && response.status < 500)) {\n\n    if (response.statusText !== 'Forbidden') {\n      response.clone().json().then((r) => {\n        notification.error({\n          // message: `Ошибка ${response.status}: ${response.url}`,\n          message: `Ошибка статус ${response.status}`,\n          description: r.Message,\n        });\n      });\n    }\n    else {\n      //router.push('/exception/403');\n    }\n    return response;\n  }\n\n  const error = new Error(errortext);\n  error.name = response.status;\n  error.response = response;\n  throw error;\n};\n\n\n/**\n * Requests a URL, returning a promise.\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [option] The options we want to pass to \"fetch\"\n * @return {object}           An object containing either \"data\" or \"err\"\n */\nexport default function request(url, option) {\n  const options = {\n    // expirys: isAntdPro(),\n    ...option,\n  };\n  /**\n   * Produce fingerprints based on url and parameters\n   * Maybe url has the same parameters\n   */\n  // const fingerprint = url + (options.body ? JSON.stringify(options.body) : '');\n  // // const hashcode = hash\n  // //   .sha256()\n  // //   .update(fingerprint)\n  // //   .digest('hex');\n\n  const defaultOptions = {\n    credentials: 'include',\n  };\n  const newOptions = { ...defaultOptions, ...options };\n  if (\n    newOptions.method === 'POST' ||\n    newOptions.method === 'PUT' ||\n    newOptions.method === 'DELETE'\n  ) {\n    if (!(newOptions.body instanceof FormData)) {\n      newOptions.headers = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json; charset=utf-8',\n        ...newOptions.headers,\n      };\n      newOptions.body = JSON.stringify(newOptions.body);\n    } else {\n      // newOptions.body is FormData\n      newOptions.headers = {\n        Accept: 'application/json',\n        ...newOptions.headers,\n      };\n    }\n  }\n\n  const authToken = setAuth(true);\n\n  if (authToken) {\n    newOptions.headers = {\n      Authorization: 'Bearer ' + authToken,\n      ...newOptions.headers,\n    };\n  } else {\n    if (newOptions.headers && newOptions.headers.Authorization)\n      delete newOptions.headers.Authorization;\n  }\n\n  /*const expirys = options.expirys && 60;\n  // options.expirys !== false, return the cache,\n  if (options.expirys !== false) {\n    const cached = sessionStorage.getItem(hashcode);\n    const whenCached = sessionStorage.getItem(`${hashcode}:timestamp`);\n    if (cached !== null && whenCached !== null) {\n      const age = (Date.now() - whenCached) / 1000;\n      if (age < expirys) {\n        const response = new Response(new Blob([cached]));\n        return response.json();\n      }\n      sessionStorage.removeItem(hashcode);\n      sessionStorage.removeItem(`${hashcode}:timestamp`);\n    }\n  }\n*/\n\n  return fetch(url, newOptions)\n    .then(checkStatus)\n    //.then(response => cachedSave(response, hashcode))\n    .then(response => {\n      // DELETE and 204 do not return data by default\n      // using .json will report an error.\n      if (newOptions.method === 'DELETE' || response.status === 204) {\n        return response.text();\n      }\n      return response.json();\n    })\n    .catch(e => {\n\n      const status = e.name;\n      if (status === 401) {\n        // @HACK\n        /* eslint-disable no-underscore-dangle */\n\n        window.g_app._store.dispatch({\n          type: 'login/logout',\n        });\n\n        return {\n          status: status,\n          message: e,\n        };\n      }\n      // environment should not be used\n      if (status === 403) {\n        //router.push('/exception/403');\n        return;\n      }\n      if (status <= 504 && status >= 500) {\n        //router.push('/exception/500');\n        return;\n      }\n      if (status >= 404 && status < 422) {\n        //router.push('/exception/404');\n      }\n\n      return {\n        status: status,\n        message: e,\n      };\n    });\n}\n"],"file":"request.js"}